<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DeDecms主要目录结构]]></title>
    <url>%2F2019%2F10%2F01%2Fmy-phpfour-logs%2F</url>
    <content type="text"><![CDATA[#简要说明1根目录 /dede 管理后台目录 /freelist 自由文档列表生成目录 /html 默认文章生成目录 /include 程序核心文件目录 /member 会员管理目录 /plus 插件及辅助功能目录 /setup 安装目录 /special 专题生成目录 /templets 默认模板存放目录 /upimg 上传下载文件保 1. 根目录 &emsp;&emsp;根目录/dede 管理后台目录/freelist 自由文档列表生成目录/html 默认文章生成目录/include 程序核心文件目录/member 会员管理目录/plus 插件及辅助功能目录/setup 安装目录/special 专题生成目录/templets 默认模板存放目录/upimg 上传下载文件保存目录base.css 基本样式表index.php 网站默认首页robots.txt 搜索控制文件 2. templets模板目录 /dedecmsv31 3模板目录/default 默认模板目录article_article.htm 普通文章页面模板article_default.htm 一般文档页面模板article_flash.htm flash页面模板article_image.htm 图集页面模板article_soft.htm 软件页面模板article_spec.htm 专题页面模板index.htm 网站首页模板index_article.htm 文章频道封面模板index_article_webart1.htmindex_article_webart2.htmindex_article_webart.htmindex_default.htm 一般文档封面模板index_flash.htm flash频道封面模板index_image.htm 图集频道封面模板index_soft.htm 软件频道封面模板list_article.htm 文章列表模板list_default.htm 一般文档列表目录模板list_flash.htm flash文档列表模板list_free.htm 自由列表模板list_image.htm 图集列表模板list_soft.htm 软件列表模板list_spec.htm 专题列表模板/img 模板图片目录（含样式表）/plus 辅助插件模板目录download_links_templet.htm 下载链接模板feedback_confirm.htm 评论确认模板feedback_templet.htm 用户评论模板feedback_templet_js.htmflink-add.htm 友情链接添加模板flink-list.htm 友情链接列表模板guestbook.htm 留言本模板heightsearch.htm 高级搜索模板js.htmrecommend.htm 推荐好友模板rss.htm RSS的XML模板rssmap.htm RSS订阅文件showphoto.htm 图片显示模板sitemap.htm 网站地图模板view_msg.htm 会员提示信息模板vote.htm 投票结果显示模板/system 系统模板目录channel_list.htm 栏目列表系统模板list_fulllist.htm 文档列表系统模板mynews.htm 站内新闻系统模板part_arclist.htm 文章列表系统模板part_autochannel.htm 分类栏目系统模板part_channelartlist.htm 包含文章列表的栏目系统模板part_imginfolist.htm 使用imginfolist标签调用的模板part_imglist.htm 使用imglist标签调用的模板part_type_list.htm 单个栏目的系统模板spec_arclist.htm 专题列表文章系统模板spec_list.htm 专题用模板tag_arclist.htmtag_fieldlist.htm fieldlist用系统模板/system/channel 频道特殊底层模板目录channel_downlinkpage.htm 下载地址列表链接模板channel_downlinks.htm 下载地址列表模板channel_spec_note.htm 专题节点列表模板 3. include目录 程序核心目录 config_base.php 环境定义文件。用于检测系统环境，定义工作目录，保存数据库链接信息，引入常用函数等，建议不要修改。config_hand.php 系统配置文件。定义系统常用的配置信息定义，可从后台管理直接生成该文件。config_passport.php 通行证文件config_rglobals.php 检测系统外部变量config_rglobals_magic.php 同上inc_archives_view.php 用于浏览文档或对文档生成HTMLinc_arclist_view.php 用于浏览频道列表或对内容列表生成HTMLinc_arcmember_view.php 用于浏览会员发布的文档inc_arcpart_view.php 用于解析和创建全局性质的模板，如频道封面，主页，单个页面等inc_arcsearch_view.php 用于文档搜索inc_arcspec_view.php 用于浏览所有专题列表或对专题列表生成HTMLinc_channel_unit.php 用户解析特定频道的附加数据结构信息inc_channel_unit_functions.php 系统共用函数集合inc_downclass.php 防采集随机字符串函数inc_freelist_view.php 用于对特定内容列表生成HTMLinc_functions.php 可供用户使用的函数集合inc_imgbt.php GetTypeidSelMemberinc_memberlogin.php 用于用户登录及获得会员状态inc_photograph.php 用于处理系统中的图片，例如水印，缩略图等inc_photowatermark_config.php 图片处理参数定义inc_rss_view.php 用于浏览频道RSS或对RSS生成静态文件inc_separate_functions.php SpGetArcList函数，用于获得文档列表inc_sitemap.php 用于生成网站地图inc_type_tree.php 用于选择栏目的目录树inc_type_tree_member.php 同上，会员使用inc_typelink.php 用于显示文章的位置和栏目位置等inc_typeunit_admin.php 用于频道管理时的一些复杂操作，主要用于后台inc_typeunit_menu.php 同上inc_userlogin.php 用于管理员登录inc_vote.php 用于管理投票jump.php 用于超链接跳转pub_charset.php 共用字符处理函数，GB/UTF-8/Unicode/BIG5等互换pub_collection.php 用于采集pub_collection_functions.php 采集用函数pub_datalist.php 后台管理用数据列表pub_datalist_dm.php 同上，不使用模板pub_db_mysql.php 用于操作数据库pub_dedehtml2.php 用于采集中的HTML解析pub_dedehtml.php HTML解析器pub_dedetag.php 用于dede模板标签解析pub_httpdown.php 用于下载http中的资源pub_oxwindow.php 后台程序扩展pub_splitword_www.php 织梦分词算法validateimg.php 验证码vdimgck.php 验证码 4. inc 共用函数目录 inc_fun_funAdmin.php 获取拼音码等函数inc_fun_funString.php html代码处理等函数inc_fun_SpGetArcList.php 获取文档列表SpGetArcList]]></content>
      <categories>
        <category>PHP&amp;DeDecms</category>
      </categories>
      <tags>
        <tag>PHP&amp;DeDecms 文件目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel5.6定时任务]]></title>
    <url>%2F2019%2F08%2F21%2Fmy-phpblog-blog%2F</url>
    <content type="text"><![CDATA[1.创建任务计划的主文件： &emsp;&emsp; 首先定位到网站根目录 这里分为两个版本架构命令 1.1 Laravel5.1定时任务1php artisan make:console 名称 1.2 Laravel5.6定时任务1php artisan make:command 名称 &emsp;&emsp;这里我写的 php artisan make:command AllConsole;&emsp;&emsp;也可以跟–command testconsole，这个就是命令的标识，加了的话待会儿在运行php artisan list的时候就可以看到这个命令，如果不加，看不到，但是照样可以执行。执行以上命令之后，会生成如下文件，我的开发环境是win10，执行计划任务最后是在Linux上执行,Windows下面只要测试通过了就可以传到Linux下。&emsp;&emsp;以下是命令执行完生成目录和文件 1D:\phpStudy\PHPTutorial\WWW\laravel\blogone56\app\Console\Commands\AllConsole.php 2.进到这个文件，修改一下代码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpnamespace App\Console\Commands;use Illuminate\Console\Command;use Log;class AllConsole extends Command&#123; /** * The name and signature of the console command. * * @var string */ protected $signature = &apos;testconsole&apos;; /** * The console command description. * * @var string */ protected $description = &apos;这是一个测试Laravel定时任务的描述&apos;; /** * Create a new command instance. * * @return void */ public function __construct() &#123; parent::__construct(); &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; // Log::info(&apos;这是我写的log&apos;); &#125;&#125; &emsp;&emsp;这个里面就三个参数，signature:信号的名字；description:任务描述；handle():方法就是要执行的代码了，里面和写一般的controller方法一样，该引用的还是要引用；我这里是写的一个定时写日志的测试； 3.写定时器： &emsp;&emsp;进到D:\phpStudy\PHPTutorial\WWW\laravel\blogone56\app\Console\Kernel.php修改如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace App\Console;use Illuminate\Console\Scheduling\Schedule;use Illuminate\Foundation\Console\Kernel as ConsoleKernel;class Kernel extends ConsoleKernel&#123; /** * The Artisan commands provided by your application. * * @var array */ protected $commands = [ // Commands\AllConsole::class, ]; /** * Define the application&apos;s command schedule. * * @param \Illuminate\Console\Scheduling\Schedule $schedule * @return void */ protected function schedule(Schedule $schedule) &#123; // $schedule-&gt;command(&apos;inspire&apos;) // -&gt;hourly(); $schedule-&gt;command(&apos;testconsole&apos;)-&gt;everyMinute(); &#125; /** * Register the commands for the application. * * @return void */ protected function commands() &#123; $this-&gt;load(__DIR__.&apos;/Commands&apos;); require base_path(&apos;routes/console.php&apos;); &#125;&#125; commands：里面需要把要用的定时任务的class都引进来；schedule：里面就可以定义执行的命令和执行的周期。&emsp;&emsp;其他可用周期可以查看如下文件： 1D:\phpStudy\PHPTutorial\WWW\laravel\blogone56\vendor\laravel\framework\src\Illuminate\Console\Scheduling\Event.php &emsp;&emsp;方法很多,这里就不重复了,进去一看就知道怎么用. 4.下面我们就在windows下面测试一下能否正常执行: &emsp;&emsp;定位根目录输入命令 1php artisan testconsole &emsp;&emsp;我在测试的方法里面没有进行输出,所以执行完命令之后没反应,但是我们直接去日志文件,可以看到我们的log信息已经写进去了,这表明任务计划代码没有问题,windows下面只能测试,真正执行任务计划要到linux下面去,windows下面也可以执行任务计划,但是比较繁琐,这里仅仅测试代码是否按照我们预想的执行.&emsp;&emsp;日志目录:&emsp;&emsp;执行结果如下: 5.把代码推到linux下,编辑定时任务: 1sudo crontab -e &emsp;&emsp;加入下面代码,就大功告成了: 1* * * * * /usr/bin/php /xxx/production/xxx/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1 &emsp;&emsp;下面这个可以静默执行，只输出你程序里面的结果,并把这些记录输出到一个指定的文件，这样的话你就可以看到哪一次没有被成功执行。 1* * * * * /usr/bin/php /xxx/production/xxx/artisan schedule:run -q &gt;&gt;/xxx/production/xxx/storage/logs/console.log 2&gt;&amp;1 &emsp;&emsp;上面的意思是用php去执行artisan里面的schedule:run这个命令,周期是每分钟都执行.&emsp;&emsp;然后我们再去Laravel.log去看一下效果,如下: &emsp;&emsp;出现这个说明任务计划已经正常执行了,每分钟被执行了一次.&emsp;&emsp;到这里,Laravel的任务计划就是这样的了. 但是还有一点疑问:我是不是需要每见一个计划任务就建个专门的命令和专门的文件?可不可以在一个文件里面写所有的任务计划? &emsp;&emsp;经过查找,发现解决方案了!以下的用法我在国内没有找到案例.&emsp;&emsp;运行命令并把结果发送邮件: 1234$schedule-&gt;command(&apos;cache:clear&apos;) -&gt;hourly() -&gt;sendOutputTo($filePath) -&gt;emailOutputTo(&apos;john@doe.com&apos;); &emsp;&emsp;直接调用类里面的方法: 1$schedule-&gt;call(&apos;SomeClass@method&apos;)-&gt;dailyAt(&apos;10:00&apos;); &emsp;&emsp;闭包调用: 123$schedule-&gt;call(function()&#123; //.. &#125;)-&gt;everyThirtyMinutes(); &emsp;&emsp;命令行: 123$schedule-&gt;terminal(&apos;gulp task&apos;)-&gt;fridays()-&gt;when(function()&#123; return true;&#125;); &emsp;&emsp;支持的时间: 123456789101112131415161718192021-&gt;hourly()-&gt;daily()-&gt;at($time) // 24 hour time-&gt;dailyAt($time)-&gt;twiceDaily()-&gt;weekdays()-&gt;mondays()-&gt;tuesdays()-&gt;wednesdays()-&gt;thursdays()-&gt;fridays()-&gt;saturdays()-&gt;sundays()-&gt;weekly()-&gt;weeklyOn($day, $time)-&gt;monthly()-&gt;yearly()-&gt;everyFiveMinutes()-&gt;everyTenMinutes()-&gt;everyThirtyMinutes()-&gt;days() // Days of the week.]]></content>
      <categories>
        <category>PHP&amp;Laravel</category>
      </categories>
      <tags>
        <tag>PHP&amp;Laravel 5.6计划任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[史上最强php生成pdf文件,html转pdf文件方法]]></title>
    <url>%2F2019%2F02%2F03%2Fmy-phpthree-blog%2F</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;之前有个客户需要把一些html页面生成pdf文件，然后我就找一些用php把html页面围成pdf文件的类。方法是可谓是找了很多很多，什么html2pdf,pdflib,FPDF这些都试过了，但是都没有达到我要的求。 &emsp;&emsp;pdflib,FPDF这两个方法是需要编写程序去生成pdf的，就也是讲不支持直接把html页面转换成pdf；html2pdf这个虽然可以把html页面转换成pdf文件，但是它只能转换一般简单的html代码，如果你的html内容要的是通过后台新闻编辑器排版的那肯定不行的。 &emsp;&emsp;纠结了半天，什么百度，谷歌搜索都用了，搜索了半天，功夫不负有心人，终于找到一个非常好用的方法了，下面就隆重介绍。 &emsp;&emsp;它就是：wkhtmltopdf，wkhtmltopdf可以直接把任何一个可以在浏览器中浏览的网页直接转换成一个pdf，首先说明一下它不是一个php类，而是一个把html页面转换成pdf的一个软件，但是它并不是一个简单的桌面软件，而且它直接cmd批处理的。而且php有个shell_exec()函数。下面就一步一步介绍如何用php来让它生成pdf文件的方法。 1.下载并安装pdf 下载地址：http://code.google.com/p/wkhtmltopdf/downloads/list上面有各种平台下安装的安装包，英文不好的直接谷歌翻译一下。下面以 windows平台上使用举例，我的下载的是wkhtmltopdf-0.9.9-installer.exe这个版本，我在win7 32位64位和windows 2003上安装测试都没有问题的。下载好以后直接安装就可以了，注意安装路径要知道，下面会用到的。安装好以后需要在系统环境变量变量名为”Path”的后添加：;C:Program Files (x86)wkhtmltopdf 也就是你安装的目录。安装好以后重启电脑。 2.测试使用效果 直接在cmd里输入： 1wkhtmltopdf http://www.shwzzz.cn/ F:website1.pdf 第一个是：运行软件名称（这个是不变的） 第二个是网址 第三个是生成后的路径及文件名。回车后是不是看生一个生成进度条的提示呢，恭喜您已经成功了，到你的生成目录里看看是不是有一个刚生成的pdf文件呢。 3.php里调用php里调用是很简单的，用shell_exec这个函数就可以了，如果shell_exec函数不能用看看php.ini里是否补禁用了。举例： 1&lt;?php shell_exec(&quot;wkhtmltopdf http://www.shwzzz.cn/ 1.pdf&quot;) ?&gt; 4.解决分页问题wkhtmltopdf 很好用，但也有些不尽人意。就是当一个html页面很长我需要在指定的地方分页那怎么办呢？ wkhtmltopdf 开发者在开发的时候并不是没有考虑到这一点，例如下面这个html页面： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;title&gt;pdf&lt;/title&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot;&gt;*&#123; margin:0px; padding:0px;&#125;div&#123; width:800px; height:1362px;margin:auto;&#125;&lt;/style&gt;&lt;body&gt;&lt;div style=&quot; background:#030&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#033&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#369&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#F60&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#F3C&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#F0F&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#0FF&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#FF0&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#00F&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#0F0&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#033&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#369&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#F60&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#030&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#033&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#369&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#F60&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#F3C&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#F0F&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#0FF&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#FF0&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#00F&quot;&gt;&lt;/div&gt;&lt;div style=&quot; background:#0F0&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 当我把它生成pdf的时候我想让每个块都是一页，经过无数次调试pdf的一页大约是1362px，但是越往后值就不对了，目前还不知道pdf一页是多少像素。 但是wkhtmltopdf 有个很好的方法，就是在那个div的样式后添加一个：page-break-inside:avoid;就ok了。 http://code.google.com/p/wkhtmltopdf/这个是wkhtmltopdf问题交流平台，但是英文的。 5.wkhtmltopdf 中文参数详解php使用事例： 123shell_exec(&quot;wkhtmltopdf --orientation Landscape http://front.dfzx12.com/?r=report/studentgene/id/2 1234567.pdf&quot;);shell_exec(&quot;wkhtmltopdf --header-center &apos;baobiao&apos; --page-width 50cm --header-line --margin-top 1cm --header-line 1.html oma11.pdf&quot;);wkhtmltopdf [OPTIONS]... &lt;input file&gt; [More input files] &lt;output file&gt; 常规选项: allow 允许加载从指定的文件夹中的文件或文件（可重复） book* 设置一会打印一本书的时候，通常设置的选项 collate 打印多份副本时整理 cookie 设置一个额外的cookie（可重复） cookie-jar 读取和写入的Cookie，并在提供的cookie jar文件 copies 复印打印成pdf文件数（默认为1） cover* 使用HTML文件作为封面。它会带页眉和页脚的TOC之前插入 custom-header 设置一个附加的HTTP头（可重复） debug-javascript 显示的javascript调试输出 default-header* 添加一个缺省的头部，与页面的左边的名称，页面数到右边，例如： –header-left ‘[webpage]’ –header-right ‘[page]/[toPage]’ –header-line disable-external-links* 禁止生成链接到远程网页 disable-internal-links* 禁止使用本地链接 disable-javascript 禁止让网页执行JavaScript disable-pdf-compression* 禁止在PDF对象使用无损压缩 disable-smart-shrinking* 禁止使用WebKit的智能战略收缩，使像素/ DPI比没有不变 disallow-local-file-access 禁止允许转换的本地文件读取其他本地文件，除非explecitily允许用 –allow dpi 显式更改DPI（这对基于X11的系统没有任何影响） enable-plugins 启用已安装的插件（如Flash encoding 设置默认的文字编码 extended-help 显示更广泛的帮助，详细介绍了不常见的命令开关 forms* 打开HTML表单字段转换为PDF表单域 grayscale PDF格式将在灰阶产生 help Display help htmldoc 输出程序HTML帮助 ignore-load-errors 忽略claimes加载过程中已经遇到了一个错误页面 lowquality 产生低品质的PDF/ PS。有用缩小结果文档的空间 manpage 输出程序手册页 margin-bottom 设置页面下边距 (default 10mm) margin-left 将左边页边距 (default 10mm) margin-right 设置页面右边距 (default 10mm) margin-top 设置页面上边距 (default 10mm) minimum-font-size 最小字体大小 (default 5) no-background 不打印背景 orientation 设置方向为横向或纵向 page-height 页面高度 (default unit millimeter) page-offset* 设置起始页码 (default 1) page-size 设置纸张大小: A4, Letter, etc. page-width 页面宽度 (default unit millimeter) password HTTP验证密码 post Add an additional post field (repeatable) post-file Post an aditional file (repeatable) print-media-type* 使用的打印介质类型，而不是屏幕 proxy 使用代理 quiet Be less verbose read-args-from-stdin 读取标准输入的命令行参数 readme 输出程序自述 redirect-delay 等待几毫秒为JS-重定向(default 200) replace* 替换名称,值的页眉和页脚（可重复） stop-slow-scripts 停止运行缓慢的JavaScripts title 生成的PDF文件的标题（第一个文档的标题使用，如果没有指定） toc* 插入的内容的表中的文件的开头 use-xserver* 使用X服务器（一些插件和其他的东西没有X11可能无法正常工作） user-style-sheet 指定用户的样式表，加载在每一页中 username HTTP认证的用户名 version 输出版本信息退出 zoom 使用这个缩放因子 (default 1) 页眉和页脚选项 header-center* (设置在中心位置的页眉内容) header-font-name* (default Arial) (设置页眉的字体名称) header-font-size* (设置页眉的字体大小) header-html* (添加一个HTML页眉,后面是网址) header-left* (左对齐的页眉文本) header-line* (显示一条线在页眉下) header-right* (右对齐页眉文本) header-spacing* (设置页眉和内容的距离,默认0) footer-center* (设置在中心位置的页脚内容) footer-font-name* (设置页脚的字体名称) footer-font-size* (设置页脚的字体大小default 11) footer-html* (添加一个HTML页脚,后面是网址) footer-left* (左对齐的页脚文本) footer-line* 显示一条线在页脚内容上) footer-right* (右对齐页脚文本) footer-spacing* (设置页脚和内容的距离)./wkhtmltopdf –footer-right ‘[page]/[topage]’ http://www.baidu.com baidu.pdf./wkhtmltopdf –header-center ‘报表’ –header-line –margin-top 2cm –header-line http://192.168.212.139/oma/ oma.pdf表内容选项中 toc-depth* Set the depth of the toc (default 3) toc-disable-back-links* Do not link from section header to toc toc-disable-links* Do not link from toc to sections toc-font-name* Set the font used for the toc (default Arial) toc-header-font-name* The font of the toc header (if unset use- - toc-font-name) toc-header-font-size* The font size of the toc header (default 15) toc-header-text* The header text of the toc (default Table Of Contents) toc-l1-font-size* Set the font size on level 1 of the toc (default 12) toc-l1-indentation* Set indentation on level 1 of the toc (default 0) toc-l2-font-size* Set the font size on level 2 of the toc (default 10) toc-l2-indentation* Set indentation on level 2 of the toc (default 20) toc-l3-font-size* Set the font size on level 3 of the toc (default 8) toc-l3-indentation* Set indentation on level 3 of the toc (default 40) toc-l4-font-size* Set the font size on level 4 of the toc (default 6) toc-l4-indentation* Set indentation on level 4 of the toc (default 60) toc-l5-font-size* Set the font size on level 5 of the toc (default 4) toc-l5-indentation* Set indentation on level 5 of the toc (default 80) toc-l6-font-size* Set the font size on level 6 of the toc (default 2) toc-l6-indentation* Set indentation on level 6 of the toc (default 100) toc-l7-font-size* Set the font size on level 7 of the toc (default 0) toc-l7-indentation* Set indentation on level 7 of the toc (default 120) toc-no-dots* Do not use dots, in the toc轮廓选项 dump-outline 转储目录到一个文件 outline 显示目录(文章中h1,h2来定) outline-depth 设置目录的深度（默认为4）页脚和页眉 [page] 由当前正在打印的页的数目代替 [frompage] 由要打印的第一页的数量取代 [topage] 由最后一页要打印的数量取代 [webpage] 通过正在打印的页面的URL替换 [section] 由当前节的名称替换 [subsection] 由当前小节的名称替换 [date] 由当前日期系统的本地格式取代 [time] 由当前时间，系统的本地格式取代./wkhtmltopdf –footer-right ‘[page]/[topage]’ http://www.baidu.com baidu.pdf./wkhtmltopdf –header-center ‘报表’ –outline –header-line –margin-top 2cm –header-line http://www.hao123.com/ hao123.pdf./wkhtmltopdf –header-left ‘[webpage]’ –footer-center ‘测试([page]/[toPage])’ http://www.baidu.com baidu.pdf]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP生成PDF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP利用curl实现get、post、put、delete、patch请求]]></title>
    <url>%2F2019%2F01%2F30%2Fmy-phptwo-blog%2F</url>
    <content type="text"><![CDATA[PHP利用curl实现get、post、put、delete、patch请求 &emsp;&emsp;现在很多web应用都使用restful api的方式来调用，PHP针对put,delete等的方法 也是可以用curl来实现的,代码如下 1. get12345678910111213function curl_get($url)&#123; $headerArray = array(&quot;Content-type:application/json;&quot;,&quot;Accept:application/json&quot;); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($url,CURLOPT_HTTPHEADER,$headerArray); $output = curl_exec($ch); curl_close($ch); $output = json_decode($output,true); return $output;&#125; 2. post123456789101112131415function curl_post($url,$data)&#123; $data = json_encode($data); $headerArray =array(&quot;Content-type:application/json;charset=&apos;utf-8&apos;&quot;,&quot;Accept:application/json&quot;); $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($curl, CURLOPT_SSL_VERIFYHOST,FALSE); curl_setopt($curl, CURLOPT_POST, 1); curl_setopt($curl, CURLOPT_POSTFIELDS, $data); curl_setopt($curl,CURLOPT_HTTPHEADER,$headerArray); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($curl); curl_close($curl); return json_decode($output，true);&#125; 3. put123456789101112function curl_put($url,$data)&#123; $data = json_encode($data); $ch = curl_init(); //初始化CURL句柄 curl_setopt($ch, CURLOPT_URL, $url); //设置请求的URL curl_setopt ($ch, CURLOPT_HTTPHEADER, array(&apos;Content-type:application/json&apos;)); curl_setopt($ch, CURLOPT_RETURNTRANSFER,1); //设为TRUE把curl_exec()结果转化为字串，而不是直接输出 curl_setopt($ch, CURLOPT_CUSTOMREQUEST,&quot;PUT&quot;); //设置请求方式 curl_setopt($ch, CURLOPT_POSTFIELDS, $data);//设置提交的字符串 $output = curl_exec($ch); curl_close($ch); return json_decode($output,true);&#125; 4. delete123456789101112function curl_del($url,$data)&#123; $data = json_encode($data); $ch = curl_init(); curl_setopt ($ch,CURLOPT_URL,$put_url); curl_setopt ($ch, CURLOPT_HTTPHEADER, array(&apos;Content-type:application/json&apos;)); curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt ($ch, CURLOPT_CUSTOMREQUEST, &quot;DELETE&quot;); curl_setopt($ch, CURLOPT_POSTFIELDS,$data); $output = curl_exec($ch); curl_close($ch); $output = json_decode($output,true);&#125; 5. patch12345678910111213function curl_patch($url,$data)&#123; $data = json_encode($data); $ch = curl_init(); curl_setopt ($ch,CURLOPT_URL,$url); curl_setopt ($ch, CURLOPT_HTTPHEADER, array(&apos;Content- type:application/json&apos;)); curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt ($ch, CURLOPT_CUSTOMREQUEST, &quot;PATCH&quot;); curl_setopt($ch, CURLOPT_POSTFIELDS,$data); $output = curl_exec($ch); curl_close($ch); $output = json_decode($output); return $output;&#125; 以上都是http的调用,https请设置相关的option。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP-&gt;curl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP接收json带有汉字 无法接收完整字符串解决]]></title>
    <url>%2F2019%2F01%2F20%2Fmy-phpone-blog%2F</url>
    <content type="text"><![CDATA[PHP接收json带有汉字 无法接收完整字符串解决 &emsp;&emsp;PHP接收json带有汉字 无法全部接收完整的json字符串 终极原因是 因为数据编码格式问题 实例 123456$database = $GLOBALS[&apos;HTTP_RAW_POST_DATA&apos;]; if(empty($database)) &#123; $database = file_get_contents(&apos;php://input&apos;);&#125;$bianma = mb_detect_encoding($database,array(&quot;ASCII&quot;,&apos;UTF-8&apos;,&quot;GB2312&quot;,&quot;GBK&quot;,&apos;BIG5&apos;)); //密码转换$database = iconv($bianma,&quot;UTF-8&quot;,$database);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP &amp; Josn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 二进制文件写入存储]]></title>
    <url>%2F2019%2F01%2F14%2Fmy-php-blog%2F</url>
    <content type="text"><![CDATA[PHP接收二进制数据 &emsp;&emsp;需求：对方给我推送的心电图 需要我来接收并返回相应的路径&emsp;&emsp;PHP HTTP接收POST数据分为三种 $_POST 方式接受数据&emsp;&emsp;$_POST 方式是由通过HTTP的POST方法传递过来的数据组成的数组,是一个自动全局变量.注:只能接收Content-Type:application/x-www-form-urlencode提交的数据.也就是只能接收表单POST过来的数据. GLOBLES[‘HTTP_RAW_POST_DATA’];&emsp;&emsp;如果访问原始POST数据不是php能够识别的文档类型, 比如:text/xml 或者soap等等,我们可以用$GLOBLES[‘HTTP_RAW_POST_DATA’]来接收,$HTTP_RAW_POST_DATA变量包含有原始POST数据.此变量仅在碰到未识别的MIME数据时产生.&emsp;&emsp;注: $HTTP_RAW_POST_DATA对于enctype=”multipart/form-data”表单数据不可用,也就是说使用$HTTP_RAW_POST_DATA无法接受网页表单post过来的数据. file_get_contents(“php://input”);&emsp;&emsp;如果访问原始POST数据, 更好的方法是使用file_get_content(“php://input”); 对于未指定Content-Type的POST数据,可以使用该方法读取POST原始数据,包括二进制流也可以.和$HTTP_RAW_POST_DATA比起来.它带来的生存眼里更小,并且不需要任何特殊的php.ini设置.&emsp;&emsp;注: php://input不能用于 enctype=”multipart/form-data”.&emsp;&emsp;例如:&emsp;&emsp;$postStr = file_get_contents(“php://input”); //获取POST数据 &emsp;&emsp;我用的是最后一种 file_get_contents(“php://input”); 1234567891011121314151617181920212223242526$imgDir = &apos;yufenbmp/&apos;; //要创建储存图片的文件夹$filename=date(&apos;YmdHis&apos;).rand(1000,9999).&quot;.png&quot;; //要生成的图片名字 $xmlstr = $GLOBALS[&apos;HTTP_RAW_POST_DATA&apos;]; //第一种接收方式if(empty($xmlstr)) &#123; //如果上边的方法接不到数据 走下边的方法 $xmlstr = file_get_contents(&apos;php://input&apos;); //第二种接收方式&#125; if(empty($xmlstr)) //判断是否有二进制数据进来&#123; echo &apos;nostream&apos;; //没有 者输出文案 exit(); &#125; $file = fopen(&quot;D:/website/phpweb/member.ekangcn.com/&quot;.$imgDir.$filename,&quot;w&quot;);//打开文件准备写入 fwrite($file,$jpg); //写入 fclose($file); //关闭 $filePath = &apos;http://xxxx.xxxxx.com/&apos;.$imgDir.$filename; echo $filePath; exit;//输出路径//图片是否存在 if(!file_exists($filePath)) &#123; echo &apos;createFail&apos;; exit(); &#125;else&#123; echo &apos;nocreateFail&apos;; exit(); &#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo基础介绍]]></title>
    <url>%2F2019%2F01%2F12%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[1.前言 &emsp;&emsp;使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等； 1.1. 准备工作 &emsp;&emsp;在开始一切之前，你必须已经： 有一个github账号，没有的话去注册一个； 安装了node.js、npm，并了解相关基础知识； 安装了git for windows（或者其它git客户端）本文所使用的环境： Windows10 node.js@10.10.0 git@2.19.1 hexo@5.1.4 2. 搭建github博客2.1. 创建仓库 &emsp;&emsp;新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了，是不是很方便？ &emsp;&emsp;由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 &emsp;&emsp;几个注意的地方： 注册的邮箱一定要验证，否则不会成功； 仓库名字必须是：username.github.io，其中username是你的用户名； 仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效； &emsp;&emsp;创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 3.配置SSH key &emsp;&emsp;为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 1$ cd ~/. ssh #检查本机已存在的ssh密钥 &emsp;&emsp;如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C &quot;邮件地址&quot; &emsp;&emsp;然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：&emsp;&emsp;将刚复制的内容粘贴到key那里，title随便填，保存。 3.1. 测试是否成功 1$ ssh -T git@github.com # 注意邮箱地址不用改 &emsp;&emsp;如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access. &emsp;&emsp;看到这个信息说明SSH已配置成功！&emsp;&emsp;此时你还需要配置： 12$ git config --global user.name &quot;liuxianan&quot;// 你的github用户名，非昵称$ git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 &emsp;&emsp;具体这个配置是干嘛的我没仔细深究。 4.使用hexo写博客4.1. hexo简介 &emsp;&emsp;Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。&emsp;&emsp;官网： http://hexo.io&emsp;&emsp;github: https://github.com/hexojs/hexo 4.2. 原理 &emsp;&emsp;由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 4.3. 注意事项 &emsp;&emsp;安装之前先来说几个注意事项： 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 4.4. 安装 1$ npm install -g hexo 4.5. 初始化 &emsp;&emsp;在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\Workspaces\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 12$ cd /f/Workspaces/hexo/$ hexo init &emsp;&emsp;hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： 12$ hexo g # 生成$ hexo s # 启动服务 &emsp;&emsp;执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的： &emsp;&emsp;hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：&emsp;&emsp;http://blog.liuxianan.com/windows-port-bind.html &emsp;&emsp;第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑 4.6. 修改主题 &emsp;&emsp;既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。 &emsp;&emsp;个人比较喜欢的2个主题：hexo-theme-jekyll 和 hexo-theme-yilia。 &emsp;&emsp;首先下载这个主题： 12$ cd /f/Workspaces/hexo/$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia &emsp;&emsp;下载后的主题都在这里： &emsp;&emsp;修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。&emsp;&emsp;如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。 4.7. 上传之前 &emsp;&emsp;在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。 4.8. 上传到github &emsp;&emsp;如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。 &emsp;&emsp;首先，ssh key肯定要配置好。 &emsp;&emsp;其次，配置_config.yml中有关deploy的部分： &emsp;&emsp;正确写法： 1234deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git branch: master &emsp;&emsp;错误写法： 1234deploy: type: github repository: https://github.com/liuxianan/liuxianan.github.io.git branch: master &emsp;&emsp;后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行hexo d的话一般会报如下错误： 1Deployer not found: github 或者 Deployer not found: git &emsp;&emsp;原因是还需要安装一个插件： 1npm install hexo-deployer-git --save &emsp;&emsp;其它命令不确定，部署这个命令一定要用git bash，否则会提示Permission denied (publickey). &emsp;&emsp;打开你的git bash，输入hexo d就会将本次有改动的代码全部提交，没有改动的不会： 4.9. 保留CNAME、README.md等文件 &emsp;&emsp;提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的： &emsp;&emsp;由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 4.10. 常用hexo命令 &emsp;&emsp;常见命令 1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 &emsp;&emsp;缩写： 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy &emsp;&emsp;组合命令： 12hexo s -g #生成并本地预览hexo d -g #生成并上传 4.11. _config.yml &emsp;&emsp;这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。 &emsp;&emsp;需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。 4.12. 写博客 &emsp;&emsp;定位到我们的hexo根目录，执行命令： 1hexo new &apos;my-first-blog&apos; &emsp;&emsp;hexo会帮我们在_posts下生成相关md文件： &emsp;&emsp;我们只需要打开这个文件就可以开始写博客了，默认生成如下内容： &emsp;&emsp;当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。 &emsp;&emsp;一般完整格式如下： 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 &emsp;&emsp;那么hexo new page ‘postName’命令和hexo new ‘postName’有什么区别呢？ 1hexo new page &quot;my-second-blog&quot; &emsp;&emsp;生成如下： &emsp;&emsp;最终部署时生成：hexo\public\my-second-blog\index.html，但是它不会作为文章出现在博文目录。 4.12.1. 写博客工具&emsp;&emsp;那么用什么工具写博客呢？这个我还没去找，以前自己使用editor.md简单弄了个，大家有好用的hexo写博客工具可以推荐个。 4.12.2. 如何让博文列表不显示全部内容&emsp;&emsp;默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？&emsp;&emsp;答案是在合适的位置加上即可，例如： 12345678910111213# 前言使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等； &emsp;&emsp;最终效果：]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo介绍</tag>
      </tags>
  </entry>
</search>
